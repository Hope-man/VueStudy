# 函数

- [函数](#%E5%87%BD%E6%95%B0)
  - [带参数默认值的函数](#%E5%B8%A6%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0)
    - [ES5实现方式](#es5%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)
    - [ES6实现方式](#es6%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)
    - [参数默认值如何影响 arguments 对象](#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-arguments-%E5%AF%B9%E8%B1%A1)
    - [参数默认值表达式](#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F)
  - [不具名参数](#%E4%B8%8D%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0)
    - [ES5 中的不具名参数](#es5-%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0)
    - [ES6 中的不具名参数(剩余参数)⭐](#es6-%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E2%AD%90)
  - [函数构造器的增强能力](#%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%A2%9E%E5%BC%BA%E8%83%BD%E5%8A%9B)
  - [扩展运算符⭐](#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E2%AD%90)
  - [ES6 的名称属性](#es6-%E7%9A%84%E5%90%8D%E7%A7%B0%E5%B1%9E%E6%80%A7)

## 带参数默认值的函数

当未传入值或传入undefined时采用默认值

### ES5实现方式

使用逻辑或运算符||，缺点：**当传入值为0或者false时，仍然会采用默认值。**

```JavaScript
// ES5实现方式
function test1(a, b, c) {
  a = a || 1;
  b = b || 2;
  c = c || function (a, b) {
    console.log("a+b: ", (a + b))
  }
  c(a, b)
}
test1()
// a+b:  3
```

### ES6实现方式

ES6 能更容易地为参数提供默认值，它使用了初始化形式，以便在参数未被正式传递进来时使用。

```JavaScript
// ES6实现方式
function test2(a = 1, b = 2, c = function (a, b) {
  console.log("a+b: ", (a + b))
}) {
  c(a, b)
}
test2()
test2(undefined)
// a+b:  3
```

### 参数默认值如何影响 arguments 对象

ES5非严格模式中arguments的值会随参数变化而变化
ES5严格模式和ES6中不会

```JavaScript
// ES5非严格
functionmixArgs(first) {
  console.log(first === arguments[0]);// true
  first = "c"; //argument[0]随之更改
  console.log(first === arguments[0]);// true
}
mixArgs("a");

//ES5严格
functionmixArgs(first) {
  "use strict";
  console.log(first === arguments[0]);// true
  first = "c"; //argument[0]不更改
  console.log(first === arguments[0]);// false
}
mixArgs("a");

// es6
functionmixArgs(first, second = "b") {
  console.log(arguments.length);// 1
  console.log(first === arguments[0]);// true
  console.log(second === arguments[1]);// false
  first = "c";
  console.log(first === arguments[0]);// false
}
mixArgs("a");
```

### 参数默认值表达式

* 参数默认值特性：
  * 默认值可以是基本类型的值或者函数。
  * 可以将前面的参数作为后面参数的默认值
  * 引用其他参数来为参数进行默认赋值时，仅允许引用前方的参数

```JavaScript
// 参数默认值范例
function getvalue(a) {
  return a + 5;
}
function add(a, b = getvalue(a)) {
  return a + b
}
console.log(add(1, 1))  // 2
console.log(add(1));  //  7
```

## 不具名参数

**不具名参数的概念主要是可以让函数读取那些未定义但是被传入的参数**

### ES5 中的不具名参数

JS 提供了arguments对象用于查看传递给函数的**对象**的所有子参数，这样就不必分别指定每个参数.

```JavaScript
function add(object) {
  console.log(object.a + object.b)
}
let obj = {
  a: 1,
  b: 2
}
add(obj) // 3
```

### ES6 中的不具名参数(剩余参数)⭐

* 不定参数的使用：
  * 使用...（展开运算符）的参数就是不定参数，它表示一个数组
  * 不限制传入参数为对象,可以直接传入多个参数,会被识别成一个数组
* 不定参数的使用限制：
  * 必须放在所有参数的末尾，不能用于对象字面量setter中。

```JavaScript
//正确写法
function add(...keys) {
  console.log(keys[0])
  console.log(a + (b + c))
}
let a = "aa";let b = 3;let c = 5
add(a, b, c) // aa  aa8
// 语法错误：不能在剩余参数后使用具名参数
functionpick(object, ...keys, last) {
  let result = Object.create(null);
  for (let i = 0, len = keys.length; i < len; i++) {
    result[keys[i]] = object[keys[i]];
  }
  return result;
}
let object = {
  // 语法错误：不能在 setter 中使用剩余参数
  set name(...value) {
    // 一些操作
  }
};
```

## 函数构造器的增强能力

ES6 增强了Function构造器的能力，允许使用默认参数以及剩余参数。对于默认参数来说，你只需为参数名称添加等于符号以及默认值

```JavaScript
var add = new Function("a = 1", "b = 2", "return a + b")
console.log(add())
var add1 = new Function("...keys", "return keys[0] + keys[1]")
console.log(add1(1, 2))
```

## 扩展运算符⭐

扩展运算符则允许将一个数组分割，并将各个项作为分离的参数传给函数,可以和剩余参数合用

```JavaScript
let values = [-25, -50, -75, -100]
console.log(Math.max(...values, 0));        // 0
```

## ES6 的名称属性

```JavaScript
```